"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.nextState = exports.MID = exports.DATA = exports.PHASE = exports.ERROR_MSG = exports.ST = void 0;
const drivers_1 = require("./drivers");
const checks_1 = require("./checks");
/**
 * State machine valid states
 */
exports.ST = {
    START: 'START',
    EMAIL_ENTERED: 'EMAIL_ENTERED',
    LOGIN_INFO_FETCH: 'LOGIN_INFO_FETCH',
    LOGIN_INFO_FAIL: 'LOGIN_INFO_FAIL',
    TENANT_FETCH: 'TENANT_FETCH',
    TENANT_SELECT: 'TENANT_SELECT',
    CONFIG_COMPLETE: 'CONFIG_COMPLETE',
    LOGIN_REDIRECT: 'LOGIN_REDIRECT',
    LOGIN: 'LOGIN',
    NO_TENANT_FOUND: 'NO_TENANT_FOUND',
    FAIL: 'FAIL',
    PASSWORD_ENTERED: 'PASSWORD_ENTERED',
    FORGOT_PASSWORD: 'FORGOT_PASSWORD',
};
exports.ERROR_MSG = 'ERROR_MSG';
exports.PHASE = 'PHASE';
exports.DATA = 'DATA';
exports.MID = 'MID';
/**
 * Gets the mid-core for the state machine
 *
 * @param st - current state
 * @return - the mid-core instance
 */
const midCore = (st) => st.get(exports.MID);
/**
 * Gets the login widget
 *
 * @param st - current state
 * @return - the login widget
 */
const loginWidget = (st) => st.get(exports.MID).loginWidget;
/**
 * Proceed to the next state given a current state.
 * @param current McKinsey ID state
 * @param next the next state to transition to
 * @return a promise that resolves once the state transitions are done
 */
const proceed = (current, next) => __awaiter(void 0, void 0, void 0, function* () {
    // if the next state is null, halt.
    if (next === null) {
        return next;
    }
    const errors = midCore(next).errors;
    try {
        if (current.get(exports.PHASE) === next.get(exports.PHASE)) {
            const phase = next.get(exports.PHASE);
            if (phase !== exports.ST.FAIL) {
                console.error('mid-sdk entered an infinite loop on phase: ', phase);
                return next.set(exports.PHASE, exports.ST.FAIL).set(exports.ERROR_MSG, errors.ERR_UNHANDLED('Internal login failure'));
            }
        }
        // We need to handle the case when the email is entered out of band with the widget itself.
        switch (next.get(exports.PHASE)) {
            case exports.ST.EMAIL_ENTERED: {
                const email = next.get(exports.DATA);
                if (!email) {
                    // no email available, go back to the start
                    return yield proceed(next, yield loginWidget(next).transition(next.set(exports.PHASE, exports.ST.START)));
                }
                else {
                    // defend against external emailToLoginInfo being bad
                    let loginInfo = {};
                    try {
                        loginInfo = yield midCore(next).emailToLoginInfo(email);
                        const loginInfoErrors = checks_1.checkLoginInfo(loginInfo);
                        if (loginInfoErrors.length > 0) {
                            return yield proceed(next, yield loginWidget(next).transition(next
                                .set(exports.PHASE, exports.ST.LOGIN_INFO_FAIL)
                                .set(exports.ERROR_MSG, errors.FAIL_CONN_LOGIN_INFO(loginInfoErrors.join(',')))));
                        }
                    }
                    catch (err) {
                        console.error('emailToLoginInfo threw an exception:', err);
                        return yield proceed(next, yield loginWidget(next).transition(next.set(exports.PHASE, exports.ST.LOGIN_INFO_FAIL).set(exports.ERROR_MSG, errors.FAIL_CONN_LOGIN_INFO())));
                    }
                    return yield proceed(next, yield loginWidget(next).transition(next.set(exports.PHASE, exports.ST.CONFIG_COMPLETE).set(exports.DATA, loginInfo)));
                }
            }
            case exports.ST.TENANT_FETCH: {
                const { accessToken, idToken, loginInfo } = next.get(exports.DATA);
                if (!accessToken || !idToken || !loginInfo) {
                    // no valid tokens for this state, failing
                    return yield proceed(next, yield loginWidget(next).transition(next.set(exports.PHASE, exports.ST.FAIL).set(exports.ERROR_MSG, errors.FAIL_BAD_TOKENS('Bad Tokens'))));
                }
                try {
                    const mid = midCore(next);
                    const driver = drivers_1.default(mid, loginInfo);
                    const email = yield driver.email(mid, loginInfo);
                    const tenants = yield mid.tenantListing(email, accessToken);
                    const tenantSelectErrors = checks_1.checkTenants(tenants.endpoints);
                    if (tenantSelectErrors.length > 0) {
                        return yield proceed(next, yield loginWidget(next).transition(next
                            .set(exports.PHASE, exports.ST.LOGIN_INFO_FAIL)
                            .set(exports.ERROR_MSG, errors.FAIL_CONN_TENANT_SELECT(tenantSelectErrors.join(', ')))));
                    }
                    return yield proceed(next, yield loginWidget(next).transition(next.set(exports.PHASE, exports.ST.TENANT_SELECT).set(exports.DATA, tenants)));
                }
                catch (err) {
                    console.error('tenantListing threw an exception:', err);
                    return yield proceed(next, yield loginWidget(next).transition(next.set(exports.PHASE, exports.ST.LOGIN_INFO_FAIL).set(exports.ERROR_MSG, errors.FAIL_CONN_TENANT_SELECT())));
                }
            }
            case exports.ST.TENANT_SELECT:
            case exports.ST.LOGIN_INFO_FAIL:
            case exports.ST.NO_TENANT_FOUND:
            case exports.ST.FAIL:
            case exports.ST.PASSWORD_ENTERED:
            case exports.ST.CONFIG_COMPLETE:
            case exports.ST.FORGOT_PASSWORD: {
                return yield proceed(next, yield loginWidget(next).transition(next));
            }
            case exports.ST.LOGIN_REDIRECT: {
                return next;
            }
            case exports.ST.LOGIN: {
                const mid = midCore(next);
                const tenant = next.get(exports.DATA);
                mid.setTenant(tenant);
                yield mid.onComplete();
                // this is a terminal state
                return next;
            }
        }
        return next;
    }
    catch (err) {
        console.error(`uncaught exception ${err.name} during state transition`, err);
        return next.set(exports.PHASE, exports.ST.FAIL).set(exports.ERROR_MSG, errors.ERR_UNHANDLED('Unknown error'));
    }
});
/**
 * Move the state machine to the next state by merging the updated properties in `next` to
 * `current`
 *
 * @param current - the current mid instance
 * @param next - the changes to apply to `current` to obtain the next state
 * @return a promise that resolves when the state machine transitions
 */
exports.nextState = (current, next) => __awaiter(void 0, void 0, void 0, function* () {
    const c = yield current;
    return proceed(c, c.merge(next));
});
