"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Mid = void 0;
const mid_oidc_core_1 = require("./mid-oidc-core");
const mid_driver_core_1 = require("./mid-driver-core");
const checks_1 = require("./checks");
const support_1 = require("./support");
/**
 * McKinsey ID Public API Surface
 */
class Mid {
    /**
     * Build the Mid object
     *
     * @param config - the configuration for McKinsey ID
     */
    constructor(config) {
        checks_1.checkConfig(config);
        this.core = checks_1.checkConfigIsOIDC(config) ? new mid_oidc_core_1.MidOIDCCore(config) : new mid_driver_core_1.MidDriverCore(config);
    }
    /**
     * Is this user authenticated and has a tenant?
     *
     * Note that this only requires that the user have a valid tenant and access token. Not that the token
     * is valid for YOUR solution. Please do not expose sensitive information before verifying that the access
     * token is valid on the server-side.
     *
     * @returns is the user authenticated?
     */
    isAuthed() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.core.isAuthed();
        });
    }
    /**
     * @return Decode the access token and return the information inside
     */
    accessInfo() {
        return support_1.getAccessInfo();
    }
    /**
     * @return Decode the id token and return the payload
     */
    idInfo() {
        return support_1.getIdInfo();
    }
    /**
     * @return the access Token used to authenticate against a remote api
     */
    accessToken() {
        return support_1.getAccessToken();
    }
    /**
     * @return the id Token used to hold the authenticated party's identity
     */
    idToken() {
        return support_1.getIdToken();
    }
    /**
     * Perform an authentication. This function suspends until a valid authenticated token exists.
     *
     * @return upon a successful authentication, a MidAuthnContext
     */
    login() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.core.login();
        });
    }
    /**
     * Attempt to refresh the user's access token
     *
     * @return an asynchronous attempt to refresh the access token
     */
    refresh() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.core.refresh();
        });
    }
    /**
     * Perform a logout. Destroys all local McKinsey ID information.
     *
     * @return a suspended promise that resolves upon completion of logout.
     */
    logout() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.core.logout();
        });
    }
    /**
     * Get user info
     */
    getUserInfo() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.core.getUserInfo();
        });
    }
}
exports.Mid = Mid;
