"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.loginResolver = exports.calculateAndSetExpTime = exports.registerActivityHandler = exports.onActivity = void 0;
/* global sessionStorage */
const consts = require("./constants");
const support_1 = require("./support");
let lastActivity;
exports.onActivity = () => {
    lastActivity = Date.now();
};
exports.registerActivityHandler = () => {
    exports.onActivity();
    document.onkeypress = exports.onActivity;
    document.onmousemove = exports.onActivity;
    document.onscroll = exports.onActivity;
};
/**
 * calculates and sets the appropriate settings for the expiration time for the access token
 *
 * @param mid - the MidCore instance
 * @param accessInfo - the decoded access token payload with iat and exp
 */
exports.calculateAndSetExpTime = (mid, accessInfo) => {
    if (!accessInfo) {
        throw new Error(mid.errors.ERR_UNHANDLED('accessInfo not valid'));
    }
    const now = Date.now();
    if (typeof accessInfo.iat !== 'number') {
        throw new Error(mid.errors.ERR_UNHANDLED(`jwt token iat value invalid. expecting number, found ${accessInfo.iat}`));
    }
    if (typeof accessInfo.exp !== 'number') {
        throw new Error(mid.errors.ERR_UNHANDLED(`jwt token exp value invalid. expecting number, found ${accessInfo.exp}`));
    }
    // exp and iat are in Seconds since UNIX Epoch, browser time is ms. Multiply by 1,000.
    const expInMs = 1000 * (accessInfo.exp - accessInfo.iat);
    sessionStorage.setItem(consts.MID_AUTH_EXPIRATION_TIME, `${expInMs + now}`);
};
/**
 * Handle mid activity on a timer tick
 *
 * @param mid the MidCore instance
 * @param inactivityMS the number of milliseconds to wait for inactivity before logging out
 * @param expTimeBufferMs the number of milliseconds to count down to until preemptively refreshing the token
 * @return a setInterval callback function
 */
const onTick = (mid, inactivityMS, expTimeBufferMs) => () => {
    const now = Date.now();
    // check for activity timeout
    if (lastActivity + inactivityMS < now) {
        // inactive... time to logout
        mid.logout();
    }
    // check if the LoginInfo context is gone, we're done here
    if (!support_1.getLoginInfo()) {
        console.error(mid.errors.ERR_UNHANDLED('LoginInfo removed, logging out.'));
        mid.logout();
    }
    // check the access token for liveliness
    const expTimeStr = sessionStorage.getItem(consts.MID_AUTH_EXPIRATION_TIME);
    if (!expTimeStr) {
        console.error(mid.errors.ERR_UNHANDLED('exptime missing! logging out.'));
        mid.logout();
    }
    else {
        const expTime = Number.parseInt(expTimeStr);
        if (isNaN(expTime)) {
            console.error(mid.errors.ERR_UNHANDLED('invalid exptime. expecting a Number, found: ' + expTimeStr + ' logging out.'));
            mid.logout();
        }
        else {
            if (expTime - expTimeBufferMs < now) {
                // blocking the tick from making multiple refresh request
                sessionStorage.setItem(consts.MID_AUTH_EXPIRATION_TIME, (expTime + expTimeBufferMs).toString());
                // we are in or past the buffer, attempt to refresh
                mid.refresh().then(() => {
                    exports.calculateAndSetExpTime(mid, support_1.getAccessInfo());
                });
            }
        }
    }
};
/**
 * creates a login resolver to set up the access token timer
 *
 * @param mid the mid instance
 * @param inactivityMs the number of milliseconds to set for the inactivity timer
 * @param  expTimeBufferMs the number of milliseconds to set for the expiration refresh
 * @return a login resolver for use in the mid instance upon login
 */
function loginResolver(mid, inactivityMs, expTimeBufferMs) {
    return ({ accessInfo }) => {
        if (!accessInfo) {
            throw new Error(mid.errors.ERR_UNHANDLED('Unable to set timer, accessToken is not a jwt'));
        }
        exports.calculateAndSetExpTime(mid, accessInfo);
        // check every second
        if (!mid.timer) {
            mid.timer = window.setInterval(onTick(mid, inactivityMs, expTimeBufferMs), 1000);
        }
    };
}
exports.loginResolver = loginResolver;
