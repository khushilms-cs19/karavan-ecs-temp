"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createCodeChallenge = exports.createCodeVerifier = exports.sha256 = exports.isRedirectLocation = exports.mkScopeStr = exports.mkScopes = exports.onComplete = exports.onLanding = exports.wrapLoginResolver = exports.tenantToLoginInfo = exports.makeMidFetch = exports.destroyStorage = exports.getIdInfo = exports.getAccessInfo = exports.getLoginInfo = exports.getTenant = exports.hasLocalTokens = exports.getIdToken = exports.getAccessToken = exports.jwtDecode = exports.jwtOrFail = exports.isInIframe = exports.queryParse = void 0;
const midfetch_1 = require("./midfetch");
const char_utils_1 = require("./char-utils");
const consts = require("./constants");
const nonce_1 = require("./nonce");
const drivers_1 = require("./drivers");
const state_machine_1 = require("./state-machine");
const errors_1 = require("./errors");
const sjcl = require("sjcl");
/**
 * Parses a query string as provided in the url query or fragment segments.
 *
 * Obeys RFC3986, does not accumulate duplicated keys as arrays
 * eg. ?x=1&x=2 will produce {x: 1} and not produce {x: [1,2]}
 *
 * @param queryString - the query string or fragment of a url
 * @returns an object representation of the query string,
 */
exports.queryParse = (queryString) => {
    // if the string is missing, empty, or effectively empty, return the empty set
    if (!queryString || queryString === '#' || queryString === '?') {
        return {};
    }
    // strip the ? or # from the query or fragment if found
    if (queryString[0] === '?' || queryString[0] === '#') {
        queryString = queryString.substring(1);
    }
    return queryString
        .split(/[&;]/)
        .map((pair) => pair.split(/=/))
        .reduce((a, [k, v]) => {
        // if v is missing but the key is present, it is null
        const val = v === undefined ? null : v;
        if (!a[k]) {
            a[k] = val ? decodeURIComponent(val) : val;
        }
        return a;
    }, {});
};
exports.isInIframe = () => window !== window.parent;
/**
 * Tests if the token is a jwt and returns it, if it is not valid it returns null
 * @param token - a possible jwt
 * @return null if invalid, the token untouched if it is valid
 */
exports.jwtOrFail = (token) => {
    const jwtRe = /[0-9a-zA-Z_-]+\.[0-9a-zA-Z_-]+\.[0-9a-zA-Z_-]+/;
    if (!token)
        return null;
    if (!token.match(jwtRe)) {
        console.error(`token not a jwt; found ${token}`);
        return null;
    }
    return token;
};
/**
 * JWT Token decoder
 * @param token - a jwt token (this will crash if this isn't tested first by jwtOrFail)
 * @return a parsed jwt
 */
function jwtDecode(token) {
    return JSON.parse(char_utils_1.b64DecodeUnicode(token.split(/\./)[1]));
}
exports.jwtDecode = jwtDecode;
exports.getAccessToken = () => exports.jwtOrFail(sessionStorage.getItem(consts.MID_ACCESS_TOKEN_KEY));
exports.getIdToken = () => exports.jwtOrFail(sessionStorage.getItem(consts.MID_ID_TOKEN_KEY));
exports.hasLocalTokens = () => !!exports.getAccessToken() && !!exports.getIdToken();
/**
 * Retrieve the Tenant from the browser state if possible, otherwise null
 * @return if a tenant exists in the browser, return it, otherwise fail
 */
exports.getTenant = () => {
    const sessionTenantJson = sessionStorage.getItem(consts.MID_TENANT_KEY);
    if (!!sessionTenantJson) {
        try {
            return JSON.parse(sessionTenantJson);
        }
        catch (err) {
            console.error(errors_1.errors.ERR_UNHANDLED('Session Tenant JSON is invalid, returning null'));
        }
    }
    return null;
};
/**
 * Retrieve the LoginInfo from the browser state if possible, otherwise null
 * @return if the login info exists in the browser, return it, otherwise fail
 */
exports.getLoginInfo = () => {
    const loginInfoJson = localStorage.getItem(`${consts.MID_LOGIN_KEY}_${document.baseURI}`);
    if (!!loginInfoJson) {
        try {
            return JSON.parse(loginInfoJson);
        }
        catch (err) {
            console.error(errors_1.errors.ERR_UNHANDLED('Login Info JSON is invalid, returning null'));
        }
    }
    return null;
};
/**
 *
 * @return the access token information
 */
exports.getAccessInfo = () => {
    const accessToken = exports.getAccessToken();
    try {
        return !!accessToken ? jwtDecode(accessToken) : null;
    }
    catch (err) {
        console.error(`unable to process access token ${accessToken}`);
        return null;
    }
};
/**
 *
 * @return the id token information
 */
exports.getIdInfo = () => {
    const idToken = exports.getIdToken();
    try {
        return !!idToken ? jwtDecode(idToken) : null;
    }
    catch (err) {
        console.error(`unable to process id token ${idToken}`);
        return null;
    }
};
/**
 * Destroys the current browser token/storage information.
 *
 * @param mid - the midcore instance
 */
exports.destroyStorage = (mid) => __awaiter(void 0, void 0, void 0, function* () {
    sessionStorage.removeItem(consts.MID_ID_TOKEN_KEY);
    sessionStorage.removeItem(consts.MID_ACCESS_TOKEN_KEY);
    sessionStorage.removeItem(consts.MID_NONCE);
    sessionStorage.removeItem(consts.MID_AUTH_EXPIRATION_TIME);
    sessionStorage.removeItem(consts.MID_TENANT_KEY);
    sessionStorage.removeItem(consts.MID_REFRESH_TOKEN_KEY);
    localStorage.removeItem(`${consts.MID_LOGIN_KEY}_${document.baseURI}`);
    localStorage.removeItem(consts.MID_TENANT_KEY);
    localStorage.removeItem(consts.MID_USER_INFO_KEY);
    localStorage.removeItem(consts.MID_CODE_VERIFIER);
    if (mid._setCookie && !exports.isInIframe()) {
        yield mid._setCookie(null).catch(() => null);
    }
});
/**
 *
 * @param mid - the midcore instance
 * @param tenant the tenant config
 * @return the midfetch function that replicates Fetch API with headers set
 */
exports.makeMidFetch = (mid, tenant) => {
    const headerHandler = () => {
        const tenantHeaders = tenant ? { 'x-tenant': tenant.tenantId } : {};
        return Object.assign(Object.assign({}, tenantHeaders), { authorization: `Bearer ${exports.getAccessToken()}` });
    };
    const refreshHandler = () => __awaiter(void 0, void 0, void 0, function* () { return yield mid.refresh(); });
    return midfetch_1.default(headerHandler, refreshHandler, () => mid.logout());
};
/**
 * Convert a tenant into a loginInfo.
 *
 * @param tenant - the tenant to get login information for
 * @returns the login information for the provided tenant
 */
function tenantToLoginInfo(tenant) {
    if (!tenant) {
        return null;
    }
    else {
        return {
            appId: tenant.appId,
            domain: tenant.domain,
            oidcConfigUrl: tenant.oidcConfigUrl,
            authDriver: tenant.authDriver,
            audience: tenant.audience,
        };
    }
}
exports.tenantToLoginInfo = tenantToLoginInfo;
/**
 * Wraps a login promise resolver with the appropriate information
 *
 * @param resolve - a promise's resolve method
 * @return a function that take a mid core instance to wrap the promise resolve method with
 */
exports.wrapLoginResolver = (resolve) => (mid) => {
    try {
        const tenant = exports.getTenant();
        const midfetch = exports.makeMidFetch(mid, tenant);
        resolve({
            midfetch,
            tenant,
            accessToken: exports.getAccessToken(),
            idToken: exports.getIdToken(),
            accessInfo: exports.getAccessInfo(),
            idInfo: exports.getIdInfo(),
        });
    }
    catch (err) {
        console.error('Failed while running Login Resolvers!');
        throw err;
    }
};
/**
 * Handle a redirect landing. This function has side-effects
 *
 * @param mid - the mid core instance
 * @param loginInfo - login configuration
 */
exports.onLanding = (mid, loginInfo) => __awaiter(void 0, void 0, void 0, function* () {
    if (!loginInfo) {
        mid.state = mid.state
            .set(state_machine_1.PHASE, state_machine_1.ST.FAIL)
            .set(state_machine_1.ERROR_MSG, mid.errors.ERR_UNHANDLED('No valid login information found'));
        return;
    }
    const resp = exports.queryParse(window.location.hash.substr(1));
    const driver = drivers_1.default(mid, loginInfo);
    try {
        driver.redirectLanding(mid, resp, loginInfo);
    }
    catch (err) {
        yield exports.destroyStorage(mid);
        mid.state = mid.state.set(state_machine_1.PHASE, state_machine_1.ST.FAIL).set(state_machine_1.ERROR_MSG, err.message);
        return;
    }
    const accessToken = resp.access_token;
    const idToken = resp.id_token;
    if (!exports.jwtOrFail(accessToken) || !exports.jwtOrFail(idToken)) {
        mid._sso = driver.attemptSSO(mid, loginInfo);
        if (!exports.jwtOrFail(exports.getAccessToken()) || !exports.jwtOrFail(exports.getIdToken())) {
            mid.state = mid.state.set(state_machine_1.PHASE, state_machine_1.ST.FAIL).set(state_machine_1.ERROR_MSG, mid.errors.ERR_UNHANDLED('Invalid token(s)'));
            return;
        }
    }
    try {
        const tenant = exports.getTenant();
        tenant
            ? driver.verifyTokens(mid, tenantToLoginInfo(tenant), { accessToken, idToken })
            : driver.verifyTokens(mid, loginInfo, { accessToken, idToken });
    }
    catch (err) {
        mid.state = mid.state.set(state_machine_1.PHASE, state_machine_1.ST.FAIL).set(state_machine_1.ERROR_MSG, mid.errors.ERR_UNHANDLED('Unable to validate tokens'));
        return;
    }
    const idInfo = jwtDecode(idToken);
    if (!nonce_1.validateNonce(idInfo.nonce)) {
        mid.state = mid.state.set(state_machine_1.PHASE, state_machine_1.ST.FAIL).set(state_machine_1.ERROR_MSG, mid.errors.ERR_MISCONFIGURATION('Nonce mismatch'));
        return;
    }
    yield mid.setTokens(idToken, accessToken);
    mid.state = mid.state
        .set(state_machine_1.PHASE, state_machine_1.ST.TENANT_FETCH)
        .set(state_machine_1.DATA, {
        idToken,
        accessToken,
        loginInfo,
    })
        .remove(state_machine_1.ERROR_MSG);
});
/**
 * Complete the login
 *
 * @param mid - the MidCore instance
 * @param loginInfo - the initial login information
 * @param idToken - the id JWT
 * @param accessToken - the access JWT
 * @param tenant - the selected Tenant
 */
exports.onComplete = (mid, loginInfo, idToken, accessToken, tenant) => __awaiter(void 0, void 0, void 0, function* () {
    // make sure the items are set
    yield mid.setTokens(idToken, accessToken);
    mid.setTenant(tenant);
    // we have a situation where the loginInfo was likely a hub and the tenant has been selected. Refresh the tokens
    // then retry the completion
    if (tenant.appId !== loginInfo.appId) {
        const driver = drivers_1.default(mid, loginInfo);
        const email = yield driver.email(mid, loginInfo);
        mid.redirectLogin(email, tenantToLoginInfo(tenant));
    }
    else {
        // Just finish the login
        mid.onLoginResolve();
        if (mid._landingFn) {
            try {
                mid._landingFn({
                    midfetch: exports.makeMidFetch(mid, tenant),
                    idToken,
                    accessToken,
                    tenant,
                });
            }
            catch (err) {
                console.error('error in landing function', err);
            }
        }
    }
});
/**
 * Creates a "scopes" set for the given array of scopes. If none are provided (ie a blank array or undefined)
 * then "openid" and "email" will be returned. If "scopes" is populated, it will return an array of the string
 * contents of "scopes" with "openid" and "email" appended. If "scopes" is not an array of strings, the behavior is
 * undefined. A Set operation is used to make sure there are no duplicates.
 *
 * @param scopes - an array of strings representing the scopes to request
 * @return the set of scopes
 */
exports.mkScopes = (scopes) => {
    const defaultScopes = ['openid', 'email'];
    if (scopes && scopes.length !== undefined) {
        return Array.from(new Set([...scopes, ...defaultScopes]));
    }
    else {
        return defaultScopes;
    }
};
/**
 * Makes a scope set as in `mkScopes` however this produces a space-delimited string instead of an array.
 *
 * @param scopes - an array of scopes
 * @return the space-delimited scopes string
 */
exports.mkScopeStr = (scopes) => {
    return exports.mkScopes(scopes).join(' ');
};
/**
 * Check if the current location url matches the redirect url
 * @param redirectUrl - the redirect url to test against
 * @returns if the current url matches the redirect url
 */
exports.isRedirectLocation = (redirectUrl) => {
    return redirectUrl.pathname === window.location.pathname;
};
const urlSafeString = (s) => {
    return s.replace(/=/g, '')
        .replace(/\+/g, '-')
        .replace(/\//g, '_');
};
exports.sha256 = (s) => {
    const bits = sjcl.hash.sha256.hash(s);
    return sjcl.codec.base64.fromBits(bits);
};
exports.createCodeVerifier = () => {
    const a = new Uint8Array(32);
    crypto.getRandomValues(a);
    return urlSafeString(btoa(String.fromCharCode.apply(null, new Uint8Array(a))));
};
exports.createCodeChallenge = (codeVerifier) => {
    const hash = exports.sha256(codeVerifier);
    return urlSafeString(hash);
};
/**
 * Run the following test in a browser, copy the output, then hexdump -C it to demonstrate that the
 * code works as intended. Nodejs crypto routines are too dissimilar to subtle crypto.
 *
 const str2ab = (str) => {
  let buf = new ArrayBuffer(str.length);
  let bufView = new Uint8Array(buf);
  for (let i=0, strLen=str.length; i < strLen; i++) {
    bufView[i] = str.charCodeAt(i);
  }
  return buf;
}

 const sha256 = async (buffer) => {
  const ab = str2ab(buffer);
  console.error(crypto.subtle.digest);
  return crypto.subtle.digest('SHA-256', ab);
};

 // has a leading zero
 sha256('the quick brown fox jumps over the lazy dog')
 .then(v => console.log(btoa(String.fromCharCode.apply(null, new Uint8Array(v)))));
 // 05c6e08f1d9fdafa03147fcb8f82f124c76d2f70e3d989dc8aadb5e7d7450bec

 // also has a leading zero
 sha256('abcdefghijklmn').then(v => console.log(btoa(String.fromCharCode.apply(null, new Uint8Array(v)))));
 // 0653c7e992d7aad40cb2635738b870e4c154afb346340d02c797d490dd52d5f9

 // has two leading zeroes
 // aaaaaaaaaaaaaaaaa
 sha256('aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' +
 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' +
 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' +
 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' +
 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' +
 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' +
 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' +
 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' +
 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa')
 .then(v => console.log(btoa(String.fromCharCode.apply(null, new Uint8Array(v)))));
*/
