"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getUserInfo = exports.verifyTokens = exports.refreshSessionTokens = exports.refreshTokens = exports.requestTokens = exports.makeOIDCLogoutURL = exports.makeOIDCUserInfoUrl = exports.makeOIDCAuthorizeUrl = exports.retrieveOIDCConfig = void 0;
/* global fetch */
const support_1 = require("./support");
const consts = require("./constants");
const checks_1 = require("./checks");
/**
 * Retrieves the OIDC config using the login info OIDC config url
 * @param mid - the MidCore instance
 * @param loginInfo - the Tenant's configuration
 * @returns OIDC Config
 * @throws if the OIDC fetch fails or the payload is invalid
 */
function retrieveOIDCConfig(mid, loginInfo) {
    return __awaiter(this, void 0, void 0, function* () {
        let rs;
        try {
            // Get the OIDC config
            rs = yield fetch(loginInfo.oidcConfigUrl.toString());
        }
        catch (err) {
            // this is likely a network connection failure from the fetch
            throw new Error(mid.errors.FAIL_RETR_METADATA('Unable to retrieve OIDC metadata'));
        }
        if (!rs.ok) {
            throw new Error(mid.errors.FAIL_RETR_METADATA('Unable to retrieve OIDC metadata, failed request'));
        }
        let json;
        try {
            json = yield rs.json();
        }
        catch (err) {
            throw new Error(mid.errors.FAIL_RETR_METADATA('Unable to retrieve OIDC metadata, invalid response'));
        }
        return json;
    });
}
exports.retrieveOIDCConfig = retrieveOIDCConfig;
/**
 * Creates the url to redirect the user to for OIDC call to /authorize
 *
 * Reaches out to the oidc well-known endpoint to get the configuration
 *
 * @param mid - the MidCore instance
 * @param authFlow - authorization flow type
 * @param props -
 * @param props.redirectUrl - the url to redirect back to when authorization is complete
 * @param props.nonce - a cryptographically secure nonce, use nonceService for this
 * @param props.loginInfo - the Tenant's configuration
 * @param props.state - any state parameter to be passed back once authorization is complete, this will be urlencoded
 * @param props.responseType - id_token, id_token token, token, code
 * @param props.email - the email provided for login hinting, if null, will not br provided
 * @param props.scopes - scopes requested
 * @param props.prompt - prompt type
 * @return the url to redirect to
 * @throws {Error} if the nonce is not provided, or if the OIDC fetch fails
 */
function makeOIDCAuthorizeUrl(mid, authFlow, props) {
    return __awaiter(this, void 0, void 0, function* () {
        const { redirectUrl, state, nonce, email, scopes, prompt, loginInfo } = props;
        if (!nonce) {
            throw new Error(mid.errors.ERR_MISCONFIGURATION('Nonce must be provided'));
        }
        const { authorization_endpoint: authorizationEndpoint } = yield retrieveOIDCConfig(mid, loginInfo);
        if (!authorizationEndpoint) {
            throw new Error(mid.errors.FAIL_RETR_METADATA('Unable to find authorization endpoint from OIDC config'));
        }
        const url = new URL(authorizationEndpoint);
        url.searchParams.append('client_id', loginInfo.appId);
        url.searchParams.append('redirect_uri', redirectUrl.toString());
        url.searchParams.append('scope', support_1.mkScopeStr(scopes));
        url.searchParams.append('state', state || '.');
        url.searchParams.append('response_mode', 'fragment');
        url.searchParams.append('nonce', nonce);
        if (authFlow === 'auth_code') {
            const codeVerifier = support_1.createCodeVerifier();
            const codeChallenge = yield support_1.createCodeChallenge(codeVerifier);
            sessionStorage.setItem(consts.MID_CODE_VERIFIER, codeVerifier);
            url.searchParams.append('code_challenge_method', 'S256');
            url.searchParams.append('code_challenge', codeChallenge);
            url.searchParams.append('response_type', 'code');
        }
        else {
            url.searchParams.append('response_type', 'id_token token');
        }
        if (loginInfo.fm) {
            url.searchParams.append('fm', loginInfo.fm);
        }
        if (email) {
            url.searchParams.append('login_hint', email);
        }
        if (prompt) {
            url.searchParams.append('prompt', prompt);
        }
        return url;
    });
}
exports.makeOIDCAuthorizeUrl = makeOIDCAuthorizeUrl;
/**
 * Creates the url to get user info from OIDC service
 *
 * Reaches out to the oidc well-known endpoint to get the configuration
 *
 * @param mid - the MidCore instance
 * @param loginInfo - the Tenant's configuration
 * @return the url to redirect to
 * @throws {Error} if the nonce is not provided, or if the OIDC fetch fails
 */
function makeOIDCUserInfoUrl(mid, loginInfo) {
    return __awaiter(this, void 0, void 0, function* () {
        const { userinfo_endpoint: userInfoEndpoint } = yield retrieveOIDCConfig(mid, loginInfo);
        if (!userInfoEndpoint) {
            throw new Error(mid.errors.FAIL_RETR_METADATA('Unable to find userinfo endpoint from OIDC config'));
        }
        return new URL(userInfoEndpoint);
    });
}
exports.makeOIDCUserInfoUrl = makeOIDCUserInfoUrl;
/**
 * Logs out the current user
 *
 * @param mid - the MidCore instance
 * @param loginInfo - the Tenant's configuration
 * @param idToken - Session id token
 * @param redirectUrl - to go after a logout
 * @return the url to redirect to
 */
function makeOIDCLogoutURL(mid, loginInfo, idToken, redirectUrl) {
    return __awaiter(this, void 0, void 0, function* () {
        const { end_session_endpoint: logoutEndpoint } = yield retrieveOIDCConfig(mid, loginInfo);
        if (!logoutEndpoint) {
            throw new Error(mid.errors.FAIL_RETR_METADATA('Unable to find logout endpoint from OIDC config'));
        }
        const logoutUrl = new URL(logoutEndpoint);
        logoutUrl.searchParams.append('id_token_hint', idToken);
        logoutUrl.searchParams.append('post_logout_redirect_uri', redirectUrl.toString());
        return logoutUrl;
    });
}
exports.makeOIDCLogoutURL = makeOIDCLogoutURL;
/**
 * Request a id_token and access_token from the OIDC /token endpoint using the authorization code
 *
 * @param mid - the MidCore instance
 * @param loginInfo - the Tenant's configuration
 * @param redirectUrl - the url to redirect back to when authorization is complete
 * @param code - returned by the authentication endpoint
 * @param codeVerifier - code verifier
 * @returns the tokens
 */
function requestTokens(mid, loginInfo, redirectUrl, code, codeVerifier) {
    return __awaiter(this, void 0, void 0, function* () {
        const { token_endpoint: tokenEndpoint } = yield retrieveOIDCConfig(mid, loginInfo);
        if (!tokenEndpoint) {
            throw new Error(mid.errors.FAIL_RETR_METADATA('Unable to find token endpoint from OIDC config'));
        }
        const body = new URLSearchParams();
        body.append('client_id', loginInfo.appId);
        body.append('grant_type', 'authorization_code');
        body.append('redirect_uri', redirectUrl.toString());
        body.append('code', code);
        body.append('code_verifier', codeVerifier);
        const tokenRs = yield fetch(tokenEndpoint, { method: 'post', body });
        if (!tokenRs.ok) {
            throw new Error(mid.errors.FAIL_RETR_TOKEN('Failed to request token from code'));
        }
        let json;
        try {
            json = yield tokenRs.json();
        }
        catch (err) {
            throw new Error(mid.errors.FAIL_RETR_TOKEN('Failed to request token from code, invalid response'));
        }
        return { accessToken: json.access_token, idToken: json.id_token, refreshToken: json.refresh_token };
    });
}
exports.requestTokens = requestTokens;
/**
 * Request a new id_token and access_token from the OIDC /token endpoint using the refresh_token
 *
 * @param mid - the MidCore instance
 * @param loginInfo the Tenant's configuration
 * @param refreshToken - a valid refresh token
 * @returns the refreshed tokens
 */
function refreshTokens(mid, loginInfo, refreshToken) {
    return __awaiter(this, void 0, void 0, function* () {
        const { token_endpoint: tokenEndpoint } = yield retrieveOIDCConfig(mid, loginInfo);
        if (!tokenEndpoint) {
            throw new Error(mid.errors.FAIL_RETR_METADATA('Unable to find token endpoint from OIDC config'));
        }
        const body = new URLSearchParams();
        body.append('client_id', loginInfo.appId);
        body.append('grant_type', 'refresh_token');
        body.append('refresh_token', refreshToken);
        const tokenRs = yield fetch(tokenEndpoint, { method: 'post', body });
        if (!tokenRs.ok) {
            throw new Error(mid.errors.FAIL_RETR_TOKEN('Failed to refresh token'));
        }
        let json;
        try {
            json = yield tokenRs.json();
        }
        catch (err) {
            throw new Error(mid.errors.FAIL_RETR_TOKEN('Failed to request token from code, invalid response'));
        }
        checks_1.checkRefreshToken(mid, json.refresh_token);
        sessionStorage.setItem(consts.MID_REFRESH_TOKEN_KEY, json.refresh_token);
        return { accessToken: json.access_token, idToken: json.id_token };
    });
}
exports.refreshTokens = refreshTokens;
/**
 * Request a new id_token and access_token from the OIDC provider using a hidden iframe
 * The iframe will load the OIDC /auth endpoint and if the user session is still valid, will collect the new tokens
 * The iframe should send a message (via window.postMessage) to its parent
 *
 * @param mid - the MidCore instance
 * @param authFlow - authorization flow type
 * @param redirectUrl - the url to redirect back to when authorization is complete
 * @param nonce - a cryptographically secure nonce, use nonceService for this
 * @param loginInfo - the Tenant's configuration
 * @returns the refreshed tokens
 */
function refreshSessionTokens(mid, authFlow, redirectUrl, nonce, loginInfo) {
    return __awaiter(this, void 0, void 0, function* () {
        const authorizeUrl = yield makeOIDCAuthorizeUrl(mid, authFlow, { redirectUrl, nonce, prompt: 'none', loginInfo });
        return new Promise((resolve, reject) => {
            const iframe = document.createElement('iframe');
            iframe.setAttribute('src', authorizeUrl.toString());
            iframe.setAttribute('title', 'silent-refresh');
            iframe.style.display = 'none';
            document.body.appendChild(iframe);
            const messageCallback = (event) => {
                const isComingFromIFrame = event.origin === window.location.origin && iframe.contentWindow === event.source;
                const isRefreshMessage = event.data && event.data.name === consts.MID_REFRESH_MESSAGE_NAME;
                if (!isComingFromIFrame || !isRefreshMessage) {
                    return;
                }
                document.body.removeChild(iframe);
                window.removeEventListener('message', messageCallback);
                if (event.data.error) {
                    return reject(event.data.error);
                }
                try {
                    const { accessToken, idToken } = event.data;
                    checks_1.checkTokens(mid, { accessToken, idToken });
                    resolve({ accessToken, idToken });
                }
                catch (err) {
                    reject(err);
                }
            };
            window.addEventListener('message', messageCallback);
        });
    });
}
exports.refreshSessionTokens = refreshSessionTokens;
/**
 * Verify tokens against the OIDC service
 *
 * Reaches out to the oidc well-known endpoint to get the configuration
 *
 * @param mid - the MidCore instance
 * @param loginInfo the Tenant's configuration
 * @param tokens to verify
 * @throws {Error} if one of the tokens is invalid, will throw an error
 */
function verifyTokens(mid, loginInfo, tokens) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!tokens) {
            throw new Error(mid.errors.ERR_UNHANDLED('No tokens provided for verification'));
        }
        const errs = [];
        const { introspection_endpoint: introspectionEndpoint } = yield retrieveOIDCConfig(mid, loginInfo);
        if (!introspectionEndpoint) {
            throw new Error(mid.errors.FAIL_RETR_METADATA('Unable to find token endpoint from OIDC config'));
        }
        const verifiers = Object.entries(tokens).map(([tokenType, token]) => __awaiter(this, void 0, void 0, function* () {
            const body = new URLSearchParams();
            body.append('client_id', loginInfo.appId);
            body.append('token', token);
            body.append('token_type_hint', tokenType);
            const tokenRs = yield fetch(introspectionEndpoint, { method: 'post', body });
            if (!tokenRs.ok) {
                errs.push(`Failed to verify ${tokenType}`);
                return;
            }
            const verifyJson = yield tokenRs.json();
            if (!verifyJson.active) {
                errs.push(`${tokenType} is not active`);
            }
        }));
        yield Promise.all(verifiers);
        if (errs.length > 0) {
            throw new Error(mid.errors.FAIL_BAD_TOKENS(errs.join(',')));
        }
    });
}
exports.verifyTokens = verifyTokens;
/**
 * Loads user info from the OIDC service
 *
 * Reaches out to the oidc well-known endpoint to get the configuration
 *
 * @param mid - the MidCore instance
 * @param loginInfo the Tenant's configuration
 * @throws {Error} if the response is invalid, will throw an error
 */
function getUserInfo(mid, loginInfo) {
    return __awaiter(this, void 0, void 0, function* () {
        const userInfoUrl = yield makeOIDCUserInfoUrl(mid, loginInfo);
        const response = yield fetch(userInfoUrl.toString(), {
            headers: { Authorization: `Bearer ${mid.accessToken()}` },
        });
        if (!response.ok) {
            throw new Error(mid.errors.ERR_UNHANDLED('Error during fetch userInfo'));
        }
        return yield response.json();
    });
}
exports.getUserInfo = getUserInfo;
