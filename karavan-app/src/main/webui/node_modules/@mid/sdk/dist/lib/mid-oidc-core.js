"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MidOIDCCore = exports.STATE = void 0;
/* eslint-disable require-jsdoc */
const mid_core_1 = require("./mid-core");
const support_1 = require("./support");
const nonce_1 = require("./nonce");
const oidc_1 = require("./oidc");
const immutable_1 = require("immutable");
const consts = require("./constants");
const state_machine_1 = require("./state-machine");
const checks_1 = require("./checks");
exports.STATE = {
    START: 'START',
    LOGIN_REDIRECT: 'LOGIN_REDIRECT',
    REDIRECT_LANDING: 'REDIRECT_LANDING',
    LOGIN: 'LOGIN',
    REFRESHING: 'REFRESHING',
    LOGOUT: 'LOGOUT',
    FAIL: 'FAIL',
};
/**
 * Private implementation for McKinsey ID OIDC Flow
 */
class MidOIDCCore extends mid_core_1.MidCore {
    /**
     * Create a new MidCore instance
     *
     * @param config - the Mid configuration
     */
    constructor(config) {
        super(config);
        this.loginInfo = config.loginInfo;
        this.authFlow = checks_1.checkAuthFlow(this.loginInfo.flow) ? this.loginInfo.flow : 'auth_code';
        this.state = immutable_1.Map().set(state_machine_1.PHASE, exports.STATE.START).set(state_machine_1.ERROR_MSG, null);
        this.setLoginInfo(this.loginInfo);
        if (this.authFlow === 'auth_code') {
            // scopes should be at least initialized to an empty array by now, via MidCore
            // this allows us to use the refresh_token to avoid 3rd party cookie blocking
            this.scopes.push('offline_access');
        }
        if (support_1.isRedirectLocation(this.redirectUrl)) {
            // A freshly logged in User comes back from IDP
            // isAuthed will wait for the redirect landing flow to finish
            this._sso = this.redirectLanding();
        }
        else if (support_1.hasLocalTokens()) {
            // A logged in User reloads the page
            // isAuthed will wait for the token refresh and login resolver (which will start the inactivity timer) to finish
            this._sso = () => this.refresh().then(() => this.onLoginResolve());
        }
        else {
            // A non logged in User starts the login flow
            // isAuthed won't need to wait for any other processes
            this._sso = Promise.resolve();
        }
    }
    onLoginResolve() {
        this.state = this.state.set(state_machine_1.PHASE, exports.STATE.LOGIN);
        super.onLoginResolve();
    }
    onLoginFailure(err) {
        const _super = Object.create(null, {
            onLoginFailure: { get: () => super.onLoginFailure }
        });
        return __awaiter(this, void 0, void 0, function* () {
            this.state = this.state.set(state_machine_1.PHASE, exports.STATE.FAIL).set(state_machine_1.ERROR_MSG, err.message);
            yield _super.onLoginFailure.call(this, err);
        });
    }
    isAuthed() {
        return __awaiter(this, void 0, void 0, function* () {
            yield (typeof this._sso === 'function' ? this._sso() : this._sso);
            return support_1.hasLocalTokens();
        });
    }
    login() {
        return __awaiter(this, void 0, void 0, function* () {
            const isAuthed = yield this.isAuthed();
            return new Promise((resolve, reject) => {
                this._loginResolvers.push(support_1.wrapLoginResolver(resolve));
                this._loginRejects.push(reject);
                if (isAuthed) {
                    this.onLoginResolve();
                }
                else if (this.state.get(state_machine_1.PHASE) === exports.STATE.START || this.state.get(state_machine_1.PHASE) === exports.STATE.FAIL) {
                    this.redirectLogin();
                }
            });
        });
    }
    refresh() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._refreshLatch) {
                return this._refreshLatch;
            }
            this.state = this.state.set(state_machine_1.PHASE, exports.STATE.REFRESHING);
            const refreshToken = sessionStorage.getItem(consts.MID_REFRESH_TOKEN_KEY);
            let refreshCall;
            if (refreshToken) {
                refreshCall = oidc_1.refreshTokens(this, this.loginInfo, refreshToken);
            }
            else {
                const nonce = nonce_1.getNonce();
                if (!nonce) {
                    throw new Error(this.errors.ERR_MISCONFIGURATION('Invalid nonce'));
                }
                refreshCall = oidc_1.refreshSessionTokens(this, this.authFlow, this.redirectUrl, nonce, this.loginInfo);
            }
            this._refreshLatch = refreshCall
                .then(({ accessToken, idToken }) => {
                this.state = this.state.set(state_machine_1.PHASE, exports.STATE.LOGIN);
                return this.setTokens(idToken, accessToken);
            })
                .catch(() => this.logout())
                .finally(() => {
                this._refreshLatch = null;
            });
            yield this._refreshLatch;
        });
    }
    logout() {
        const _super = Object.create(null, {
            logout: { get: () => super.logout }
        });
        return __awaiter(this, void 0, void 0, function* () {
            this.state = this.state.set(state_machine_1.PHASE, exports.STATE.LOGOUT);
            const idToken = support_1.getIdToken();
            yield _super.logout.call(this);
            if (idToken) {
                const logoutUrl = yield oidc_1.makeOIDCLogoutURL(this, this.loginInfo, idToken, this.logoutRedirectUrl);
                window.location.assign(logoutUrl.toString());
            }
            else {
                window.location.assign(this.logoutRedirectUrl);
            }
        });
    }
    getUserInfo() {
        return __awaiter(this, void 0, void 0, function* () {
            const user = localStorage.getItem(consts.MID_USER_INFO_KEY);
            if (user) {
                return JSON.parse(user);
            }
            try {
                const user = yield oidc_1.getUserInfo(this, this.loginInfo);
                localStorage.setItem(consts.MID_USER_INFO_KEY, JSON.stringify(user));
                return user;
            }
            catch (err) {
                console.error(Error(this.errors.ERR_UNHANDLED(err)));
            }
            return null;
        });
    }
    /**
     * Handle the redirectUri landing
     */
    redirectLanding() {
        return __awaiter(this, void 0, void 0, function* () {
            this.state = this.state.set(state_machine_1.PHASE, exports.STATE.REDIRECT_LANDING);
            // If we land on the callback with no code and no tokens, just try to proceed and see what happens
            if (window.location.hash === '' || window.location.hash === undefined || window.location.hash === null) {
                yield this.onComplete();
                return;
            }
            const res = support_1.queryParse(window.location.hash.substr(1));
            const { access_token: accessToken, id_token: idToken, code, error, error_description } = res;
            try {
                const endRedirect = ({ accessToken, idToken }) => __awaiter(this, void 0, void 0, function* () {
                    checks_1.checkTokens(this, { accessToken, idToken });
                    yield this.setTokens(idToken, accessToken);
                    window.parent.postMessage({ name: consts.MID_REFRESH_MESSAGE_NAME, idToken, accessToken }, window.location.origin);
                    yield this.onComplete();
                });
                if (error) {
                    console.error('Redirect Error', error, error_description);
                    throw new Error(this.errors.ERR_UNHANDLED('Invalid redirect response'));
                }
                else if (code) {
                    // Authorization Code Flow w/ PKCE
                    const codeVerifier = sessionStorage.getItem(consts.MID_CODE_VERIFIER);
                    const { accessToken, idToken, refreshToken } = yield oidc_1.requestTokens(this, this.loginInfo, this.redirectUrl, code, codeVerifier);
                    checks_1.checkRefreshToken(this, refreshToken);
                    sessionStorage.setItem(consts.MID_REFRESH_TOKEN_KEY, refreshToken);
                    yield endRedirect({ accessToken, idToken });
                }
                else if (!accessToken && !idToken) {
                    // implicit flow fall-thru failure
                    const err = new Error(this.errors.ERR_MISCONFIGURATION('Unknown OIDC authentication flow.'));
                    window.parent.postMessage({ name: consts.MID_REFRESH_MESSAGE_NAME, error: err }, window.location.origin);
                    yield this.onLoginFailure(err);
                    return;
                }
                else {
                    // Implicit flow
                    yield endRedirect({ accessToken, idToken });
                }
            }
            catch (err) {
                window.parent.postMessage({ name: consts.MID_REFRESH_MESSAGE_NAME, error: err }, window.location.origin);
                yield this.onLoginFailure(err);
            }
        });
    }
    /**
     * Redirects to the OIDC /authorize endpoint
     */
    redirectLogin() {
        return __awaiter(this, void 0, void 0, function* () {
            const nonce = nonce_1.makeNonce();
            nonce_1.storeNonce(nonce);
            this.state = this.state.set(state_machine_1.PHASE, exports.STATE.LOGIN_REDIRECT);
            try {
                const authorizeUrl = yield oidc_1.makeOIDCAuthorizeUrl(this, this.authFlow, {
                    nonce,
                    redirectUrl: this.redirectUrl,
                    scopes: this.scopes,
                    loginInfo: this.loginInfo,
                });
                window.location.assign(authorizeUrl.toString());
            }
            catch (err) {
                yield this.onLoginFailure(err);
            }
        });
    }
}
exports.MidOIDCCore = MidOIDCCore;
