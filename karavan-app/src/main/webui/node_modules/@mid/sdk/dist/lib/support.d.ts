import { AccessInfo, IdInfo, LoginInfo, MidAuthnContext, MidFetch, Tenant } from '../types';
import { MidCore } from './mid-core';
import { MidDriverCore } from './mid-driver-core';
/**
 * Parses a query string as provided in the url query or fragment segments.
 *
 * Obeys RFC3986, does not accumulate duplicated keys as arrays
 * eg. ?x=1&x=2 will produce {x: 1} and not produce {x: [1,2]}
 *
 * @param queryString - the query string or fragment of a url
 * @returns an object representation of the query string,
 */
export declare const queryParse: (queryString: string) => Record<string, string | null>;
export declare const isInIframe: () => boolean;
/**
 * Tests if the token is a jwt and returns it, if it is not valid it returns null
 * @param token - a possible jwt
 * @return null if invalid, the token untouched if it is valid
 */
export declare const jwtOrFail: (token: string | null) => string | null;
/**
 * JWT Token decoder
 * @param token - a jwt token (this will crash if this isn't tested first by jwtOrFail)
 * @return a parsed jwt
 */
export declare function jwtDecode<T>(token: string): T;
export declare const getAccessToken: () => string | null;
export declare const getIdToken: () => string | null;
export declare const hasLocalTokens: () => boolean;
/**
 * Retrieve the Tenant from the browser state if possible, otherwise null
 * @return if a tenant exists in the browser, return it, otherwise fail
 */
export declare const getTenant: () => Tenant | null;
/**
 * Retrieve the LoginInfo from the browser state if possible, otherwise null
 * @return if the login info exists in the browser, return it, otherwise fail
 */
export declare const getLoginInfo: () => LoginInfo | null;
/**
 *
 * @return the access token information
 */
export declare const getAccessInfo: () => AccessInfo | null;
/**
 *
 * @return the id token information
 */
export declare const getIdInfo: () => IdInfo | null;
/**
 * Destroys the current browser token/storage information.
 *
 * @param mid - the midcore instance
 */
export declare const destroyStorage: (mid: MidCore) => Promise<void>;
/**
 *
 * @param mid - the midcore instance
 * @param tenant the tenant config
 * @return the midfetch function that replicates Fetch API with headers set
 */
export declare const makeMidFetch: (mid: MidCore, tenant: Tenant | null) => MidFetch;
export declare function tenantToLoginInfo(tenant: Tenant): LoginInfo;
export declare function tenantToLoginInfo(tenant: null): null;
/**
 * Wraps a login promise resolver with the appropriate information
 *
 * @param resolve - a promise's resolve method
 * @return a function that take a mid core instance to wrap the promise resolve method with
 */
export declare const wrapLoginResolver: (resolve: (c: MidAuthnContext) => void) => (mid: MidCore) => void;
/**
 * Handle a redirect landing. This function has side-effects
 *
 * @param mid - the mid core instance
 * @param loginInfo - login configuration
 */
export declare const onLanding: (mid: MidDriverCore, loginInfo: LoginInfo) => Promise<void>;
/**
 * Complete the login
 *
 * @param mid - the MidCore instance
 * @param loginInfo - the initial login information
 * @param idToken - the id JWT
 * @param accessToken - the access JWT
 * @param tenant - the selected Tenant
 */
export declare const onComplete: (mid: MidDriverCore, loginInfo: LoginInfo, idToken: string, accessToken: string, tenant: Tenant) => Promise<void>;
/**
 * Creates a "scopes" set for the given array of scopes. If none are provided (ie a blank array or undefined)
 * then "openid" and "email" will be returned. If "scopes" is populated, it will return an array of the string
 * contents of "scopes" with "openid" and "email" appended. If "scopes" is not an array of strings, the behavior is
 * undefined. A Set operation is used to make sure there are no duplicates.
 *
 * @param scopes - an array of strings representing the scopes to request
 * @return the set of scopes
 */
export declare const mkScopes: (scopes?: string[] | null | undefined) => string[];
/**
 * Makes a scope set as in `mkScopes` however this produces a space-delimited string instead of an array.
 *
 * @param scopes - an array of scopes
 * @return the space-delimited scopes string
 */
export declare const mkScopeStr: (scopes?: string[] | null | undefined) => string;
/**
 * Check if the current location url matches the redirect url
 * @param redirectUrl - the redirect url to test against
 * @returns if the current url matches the redirect url
 */
export declare const isRedirectLocation: (redirectUrl: URL) => boolean;
export declare const sha256: (s: string) => string;
export declare const createCodeVerifier: () => string;
export declare const createCodeChallenge: (codeVerifier: string) => string;
/**
 * Run the following test in a browser, copy the output, then hexdump -C it to demonstrate that the
 * code works as intended. Nodejs crypto routines are too dissimilar to subtle crypto.
 *
 const str2ab = (str) => {
  let buf = new ArrayBuffer(str.length);
  let bufView = new Uint8Array(buf);
  for (let i=0, strLen=str.length; i < strLen; i++) {
    bufView[i] = str.charCodeAt(i);
  }
  return buf;
}

 const sha256 = async (buffer) => {
  const ab = str2ab(buffer);
  console.error(crypto.subtle.digest);
  return crypto.subtle.digest('SHA-256', ab);
};

 // has a leading zero
 sha256('the quick brown fox jumps over the lazy dog')
 .then(v => console.log(btoa(String.fromCharCode.apply(null, new Uint8Array(v)))));
 // 05c6e08f1d9fdafa03147fcb8f82f124c76d2f70e3d989dc8aadb5e7d7450bec

 // also has a leading zero
 sha256('abcdefghijklmn').then(v => console.log(btoa(String.fromCharCode.apply(null, new Uint8Array(v)))));
 // 0653c7e992d7aad40cb2635738b870e4c154afb346340d02c797d490dd52d5f9

 // has two leading zeroes
 // aaaaaaaaaaaaaaaaa
 sha256('aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' +
 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' +
 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' +
 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' +
 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' +
 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' +
 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' +
 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' +
 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa')
 .then(v => console.log(btoa(String.fromCharCode.apply(null, new Uint8Array(v)))));
*/
