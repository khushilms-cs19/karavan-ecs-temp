"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MidCore = void 0;
/* global sessionStorage, localStorage */
const immutable_1 = require("immutable");
const consts = require("./constants");
const timer_1 = require("./timer");
const errors_1 = require("./errors");
const support_1 = require("./support");
/**
 * Private implementation for McKinsey ID
 */
class MidCore {
    /**
     * Create a new MidCore instance
     *
     * @param config - the Mid configuration
     */
    constructor(config) {
        timer_1.registerActivityHandler();
        this.state = immutable_1.Map();
        this.redirectUrl = new URL(config.redirectUrl.toString());
        this.logoutRedirectUrl = config.logoutRedirectUrl;
        this.scopes = config.scopes || [];
        this.errors = errors_1.makeErrors(config.errors);
        this.timer = null;
        this._loginResolvers = [
            support_1.wrapLoginResolver(timer_1.loginResolver(this, consts.INACTIVITY_TIMEOUT_MS, consts.EXP_TIME_BUFFER_MS)),
        ];
        this._loginRejects = [];
        if (config.landingFn) {
            this._landingFn = config.landingFn;
        }
        if (config.setCookie) {
            this._setCookie = config.setCookie;
        }
        this._refreshLatch = null;
        this._sso = null;
    }
    /**
     * Resolve promises for all registered login resolvers
     */
    onLoginResolve() {
        if (this._loginResolvers.length > 0) {
            // store off the current list of login resolvers just in case another one
            // gets added while we are resolving
            const lrs = this._loginResolvers;
            // re-initialize a new list of login resolvers
            this._loginResolvers = [];
            // resolve
            try {
                for (const lr of lrs) {
                    lr(this);
                }
            }
            catch (err) {
                console.error(this.errors.ERR_UNHANDLED('Unhandled error during login resolution'));
                this.logout();
            }
        }
    }
    /**
     * Calls on error in the login flow, destroys storage
     * @param err - Error
     */
    onLoginFailure(err) {
        return __awaiter(this, void 0, void 0, function* () {
            console.error(err);
            try {
                this._loginRejects.forEach((lr) => lr(err));
                this._loginRejects = [];
            }
            catch (err) {
                console.error(this.errors.ERR_UNHANDLED('Unhandled error during login rejection'));
            }
            yield support_1.destroyStorage(this);
        });
    }
    /**
     * To call when the login flow is complete
     * Resolves all login resolvers and calls to landingFn if needed.
     */
    onComplete() {
        return __awaiter(this, void 0, void 0, function* () {
            this.onLoginResolve();
            if (this._landingFn) {
                const tenant = support_1.getTenant();
                const accessToken = this.accessToken();
                const idToken = this.idToken();
                try {
                    yield this._landingFn({
                        midfetch: support_1.makeMidFetch(this, tenant),
                        idToken,
                        accessToken,
                        tenant,
                    });
                }
                catch (err) {
                    console.error('error in landing function', err);
                }
            }
        });
    }
    /**
     * Sets the tokens for this mid instance
     * @param idToken the ID Token from an OIDC IdP
     * @param accessToken the Access Token from an OIDC IdP
     * @return the mid instance
     */
    setTokens(idToken, accessToken) {
        return __awaiter(this, void 0, void 0, function* () {
            sessionStorage.setItem(consts.MID_ID_TOKEN_KEY, idToken);
            sessionStorage.setItem(consts.MID_ACCESS_TOKEN_KEY, accessToken);
            yield this.setCookie();
            return this;
        });
    }
    /**
     * Sets the loginInfo for this mid instance
     * @param loginInfo - The login info
     * @return the mid instance
     */
    setLoginInfo(loginInfo) {
        const loginInfoJson = JSON.stringify(loginInfo);
        localStorage.setItem(`${consts.MID_LOGIN_KEY}_${document.baseURI}`, loginInfoJson);
        return this;
    }
    /**
     * Sets the browser state for the tenant config provided
     *
     * @param tenantConfig - the tenant configuration
     * @return the mid instance
     */
    setTenant(tenantConfig) {
        const tenantJson = JSON.stringify(tenantConfig);
        sessionStorage.setItem(consts.MID_TENANT_KEY, tenantJson);
        return this;
    }
    /**
     * Tries to set the cookies for the client
     *
     * @return the mid instance
     */
    setCookie() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this._setCookie) {
                return this;
            }
            const tenant = support_1.getTenant();
            const accessToken = this.accessToken();
            const idToken = this.idToken();
            if (accessToken && idToken) {
                yield this._setCookie({ accessToken, idToken, tenant: tenant === null || tenant === void 0 ? void 0 : tenant.tenantId });
            }
            return this;
        });
    }
    /**
     * Is the user authenticated?
     *
     * @return is this user logged in (after checking sso)
     */
    isAuthed() {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error(this.errors.ERR_UNSUPPORTED());
        });
    }
    /**
     * Attempt to log the user in.
     *
     * @return authentication context
     */
    login() {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error(this.errors.ERR_UNSUPPORTED());
        });
    }
    /**
     * Attempt to refresh the user's tokens, the driver is responsible for destroying the
     * login information if there is any problem refreshing.
     *
     * @return suspends until the refresh is complete
     */
    refresh() {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error(this.errors.ERR_UNSUPPORTED());
        });
    }
    /**
     * Log the user out
     */
    logout() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.timer) {
                clearInterval(this.timer);
            }
            yield support_1.destroyStorage(this);
        });
    }
    /**
     * @return the access Token used to authenticate against a remote api
     */
    accessToken() {
        return support_1.getAccessToken();
    }
    /**
     * @return the id Token used to hold the authenticated party's identity
     */
    idToken() {
        return support_1.getIdToken();
    }
    /**
     * Get user info.
     *
     * @return UserInfo
     */
    getUserInfo() {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error(this.errors.ERR_UNSUPPORTED());
        });
    }
}
exports.MidCore = MidCore;
